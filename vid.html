<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GeoCam Verifier</title>
    <style>
        :root {
            --bg-color: #000000;
            --surface-color: #1e1e1e;
            --primary-color: #3b82f6;
            --text-color: #ffffff;
            --verified-color: #4ade80; /* Green */
            --warning-color: #f59e0b;  /* Yellow */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--surface-color);
        }

        #viewport {
            flex-grow: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        video, #photo-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #photo-preview { display: none; }

        /* Controls */
        #controls {
            height: 140px;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding-bottom: 20px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .btn-circle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid white;
            background: transparent;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .btn-circle:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }

        .btn-icon {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 10px;
            opacity: 0.8;
        }

        .btn-text {
            padding: 12px 24px;
            border-radius: 30px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
        }

        .btn-primary { background: var(--primary-color); color: white; }
        .btn-secondary { background: rgba(255, 255, 255, 0.2); color: white; }

        svg { width: 32px; height: 32px; fill: currentColor; }
        .hidden { display: none !important; }
        
        #result-actions {
            display: none;
            gap: 20px;
            width: 100%;
            justify-content: center;
        }

        canvas { display: none; }

        /* Status Pills */
        #status-container {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 20;
            pointer-events: none;
        }

        .pill {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: #ccc;
            display: flex;
            align-items: center;
            gap: 6px;
            max-width: 80%;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        /* Status Colors */
        .status-ok .dot { background: var(--verified-color); box-shadow: 0 0 8px var(--verified-color); }
        .status-warn .dot { background: var(--warning-color); }
        .status-err .dot { background: #ef4444; }

    </style>
</head>
<body>

<div id="app-container">
    
    <div id="status-container">
        <div id="loc-pill" class="pill status-warn">
            <span class="dot"></span>
            <span id="loc-text">Waiting for GPS...</span>
        </div>
        <div id="time-pill" class="pill status-warn">
            <span class="dot"></span>
            <span id="time-text">System Time</span>
        </div>
    </div>

    <div id="viewport">
        <video id="video" autoplay playsinline muted></video>
        <img id="photo-preview" alt="Captured Result">
    </div>

    <div id="controls">
        <button id="switch-btn" class="btn-icon">
            <svg viewBox="0 0 24 24"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"/></svg>
        </button>

        <button id="capture-btn" class="btn-circle"></button>

        <div style="width: 32px;"></div>

        <div id="result-actions">
            <button id="retry-btn" class="btn-text btn-secondary">Retry</button>
            <a id="download-link">
                <button class="btn-text btn-primary">Download</button>
            </a>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
    // UI Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const photoPreview = document.getElementById('photo-preview');
    const captureBtn = document.getElementById('capture-btn');
    const switchBtn = document.getElementById('switch-btn');
    const retryBtn = document.getElementById('retry-btn');
    const downloadLink = document.getElementById('download-link');
    const resultActions = document.getElementById('result-actions');
    const ctx = canvas.getContext('2d');
    
    // Status Elements
    const locPill = document.getElementById('loc-pill');
    const locText = document.getElementById('loc-text');
    const timePill = document.getElementById('time-pill');
    const timeText = document.getElementById('time-text');

    // State
    let currentStream = null;
    let facingMode = 'environment';
    
    // Data State
    let state = {
        lat: null,
        lon: null,
        address: null,
        timeOffset: 0, // Difference between System Time and Internet Time
        isTimeVerified: false,
        fetchingLoc: false,
        fetchingTime: false
    };

    // --- 1. Geolocation Logic ---
    function initLocation() {
        if ("geolocation" in navigator) {
            navigator.geolocation.watchPosition(
                async (pos) => {
                    state.lat = pos.coords.latitude;
                    state.lon = pos.coords.longitude;
                    
                    // Update UI to show we have coordinates
                    if (!state.address) {
                        locText.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)}`;
                        locPill.className = "pill status-ok";
                    }

                    // Trigger Data Fetch (Only if not already successful)
                    if (!state.address && !state.fetchingLoc) fetchAddress();
                    if (!state.isTimeVerified && !state.fetchingTime) syncInternetTime();
                },
                (err) => {
                    locText.textContent = "GPS Error";
                    locPill.className = "pill status-err";
                },
                { enableHighAccuracy: true }
            );
        } else {
            locText.textContent = "No GPS Support";
        }
    }

    // --- 2. Address Fetch (Nominatim) ---
    async function fetchAddress() {
        state.fetchingLoc = true;
        try {
            const ctrl = new AbortController();
            setTimeout(() => ctrl.abort(), 4000); // 4s timeout

            const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${state.lat}&lon=${state.lon}`, { signal: ctrl.signal });
            if (!res.ok) throw new Error("Addr Fail");
            const data = await res.json();
            
            const a = data.address;
            const parts = [];
            if (a.suburb || a.neighbourhood) parts.push(a.suburb || a.neighbourhood);
            if (a.city || a.town || a.village) parts.push(a.city || a.town || a.village);
            if (a.country) parts.push(a.country);
            
            state.address = parts.slice(0, 3).join(', ');
            locText.textContent = state.address;
            locPill.className = "pill status-ok";
        } catch (e) {
            console.log("Addr Fetch Failed", e);
        } finally {
            state.fetchingLoc = false;
        }
    }

    // --- 3. Internet Time Sync ---
    async function syncInternetTime() {
        state.fetchingTime = true;
        timeText.textContent = "Syncing Time...";
        
        try {
            const ctrl = new AbortController();
            setTimeout(() => ctrl.abort(), 5000); // 5s timeout

            // Use timeapi.io to get local time for these coordinates
            const url = `https://timeapi.io/api/Time/current/coordinate?latitude=${state.lat}&longitude=${state.lon}`;
            const res = await fetch(url, { signal: ctrl.signal });
            
            if (!res.ok) throw new Error("Time API Fail");
            
            const data = await res.json();
            
            // Parse Internet Time
            const internetTime = new Date(data.dateTime);
            const deviceTime = new Date();
            
            // Calculate Offset (Internet - Device)
            state.timeOffset = internetTime.getTime() - deviceTime.getTime();
            state.isTimeVerified = true;
            
            timeText.textContent = "Internet Time Verified";
            timePill.className = "pill status-ok";
            
        } catch (e) {
            console.log("Time Sync Failed", e);
            state.isTimeVerified = false;
            state.timeOffset = 0;
            timeText.textContent = "System Time (Offline)";
            timePill.className = "pill status-warn";
        } finally {
            state.fetchingTime = false;
        }
    }

    // --- 4. Camera Logic ---
    async function startCamera() {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            currentStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: facingMode, width: { ideal: 1920 }, height: { ideal: 1080 } },
                audio: false
            });
            video.srcObject = currentStream;
        } catch (err) {
            alert("Camera Error: " + err.message);
        }
    }

    switchBtn.addEventListener('click', () => {
        facingMode = facingMode === 'environment' ? 'user' : 'environment';
        startCamera();
    });

    // --- 5. Capture & Overlay ---
    captureBtn.addEventListener('click', () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        // Mirror front camera
        if (facingMode === 'user') {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
        }
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (facingMode === 'user') ctx.setTransform(1, 0, 0, 1, 0, 0);

        drawOverlay();

        const dataURL = canvas.toDataURL('image/jpeg', 0.95);
        photoPreview.src = dataURL;
        video.classList.add('hidden');
        photoPreview.style.display = 'block';
        captureBtn.classList.add('hidden');
        switchBtn.classList.add('hidden');
        resultActions.style.display = 'flex';

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        downloadLink.href = dataURL;
        downloadLink.download = `VerifiedSnap-${timestamp}.jpg`;
    });

    function drawOverlay() {
        const h = canvas.height;
        const w = canvas.width;
        
        // Background Gradient
        const gradient = ctx.createLinearGradient(0, h - 250, 0, h);
        gradient.addColorStop(0, "transparent");
        gradient.addColorStop(1, "rgba(0,0,0,0.95)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, h - 250, w, 250);

        ctx.fillStyle = "white";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 4;
        ctx.textAlign = "left";

        // --- Calculate Correct Time ---
        // Apply the offset to get the real internet time right now
        const now = new Date(Date.now() + state.timeOffset);
        const timeStr = now.toLocaleString([], { 
            weekday: 'short', 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric',
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit'
        });

        // --- Draw Time ---
        const fontSizeTime = Math.floor(w * 0.045); 
        ctx.font = `bold ${fontSizeTime}px sans-serif`;
        ctx.fillText(timeStr, 20, h - 110);
        
        // Add "Verified" badge if internet time was used
        if (state.isTimeVerified) {
             const badgeSize = Math.floor(w * 0.025);
             ctx.font = `bold ${badgeSize}px sans-serif`;
             ctx.fillStyle = "#4ade80"; // Green
             ctx.fillText("✓ Internet Time", 20, h - 160);
             ctx.fillStyle = "white"; // Reset
        } else {
             const badgeSize = Math.floor(w * 0.025);
             ctx.font = `bold ${badgeSize}px sans-serif`;
             ctx.fillStyle = "#f59e0b"; // Yellow
             ctx.fillText("⚠ System Time", 20, h - 160);
             ctx.fillStyle = "white";
        }

        // --- Draw Location ---
        const fontSizeLoc = Math.floor(w * 0.03);
        ctx.font = `${fontSizeLoc}px sans-serif`;
        const locString = state.address || `Lat: ${state.lat?.toFixed(5)} Lon: ${state.lon?.toFixed(5)}`;
        wrapText(ctx, locString, 20, h - 60, w - 40, fontSizeLoc * 1.5);
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = context.measureText(testLine);
            if (metrics.width > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            } else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }

    retryBtn.addEventListener('click', () => {
        photoPreview.style.display = 'none';
        video.classList.remove('hidden');
        resultActions.style.display = 'none';
        captureBtn.classList.remove('hidden');
        switchBtn.classList.remove('hidden');
    });

    initLocation();
    startCamera();

</script>
</body>
</html>
