<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GeoCam Pro v2</title>
    <style>
        :root {
            --bg-color: #000000;
            --surface-color: #1e1e1e;
            --primary-color: #3b82f6;
            --text-color: #ffffff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--surface-color);
        }

        #viewport {
            flex-grow: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        video, #photo-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #photo-preview { display: none; }

        #controls {
            height: 140px;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding-bottom: 20px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .btn-circle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid white;
            background: transparent;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .btn-circle:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }

        .btn-icon {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 10px;
            opacity: 0.8;
        }

        .btn-text {
            padding: 12px 24px;
            border-radius: 30px;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
        }

        .btn-primary { background: var(--primary-color); color: white; }
        .btn-secondary { background: rgba(255, 255, 255, 0.2); color: white; }

        svg { width: 32px; height: 32px; fill: currentColor; }
        .hidden { display: none !important; }
        
        #result-actions {
            display: none;
            gap: 20px;
            width: 100%;
            justify-content: center;
        }

        canvas { display: none; }

        #status-pill {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 13px;
            color: #ccc;
            pointer-events: none;
            z-index: 20;
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            display: inline-block;
        }
        .dot.active { background: #4ade80; box-shadow: 0 0 8px #4ade80; }
        .dot.warn { background: #f59e0b; box-shadow: 0 0 8px #f59e0b; }

    </style>
</head>
<body>

<div id="app-container">
    
    <div id="status-pill">
        <span class="dot" id="gps-dot"></span>
        <span id="location-text">Waiting for GPS...</span>
    </div>

    <div id="viewport">
        <video id="video" autoplay playsinline muted></video>
        <img id="photo-preview" alt="Captured Result">
    </div>

    <div id="controls">
        <button id="switch-btn" class="btn-icon">
            <svg viewBox="0 0 24 24"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"/></svg>
        </button>

        <button id="capture-btn" class="btn-circle"></button>

        <div style="width: 32px;"></div>

        <div id="result-actions">
            <button id="retry-btn" class="btn-text btn-secondary">Retry</button>
            <a id="download-link">
                <button class="btn-text btn-primary">Download</button>
            </a>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const photoPreview = document.getElementById('photo-preview');
    const captureBtn = document.getElementById('capture-btn');
    const switchBtn = document.getElementById('switch-btn');
    const retryBtn = document.getElementById('retry-btn');
    const downloadLink = document.getElementById('download-link');
    const resultActions = document.getElementById('result-actions');
    const locText = document.getElementById('location-text');
    const gpsDot = document.getElementById('gps-dot');
    const ctx = canvas.getContext('2d');

    let currentStream = null;
    let facingMode = 'environment';
    let humanAddress = null;
    let rawLat = null;
    let rawLon = null;
    let isFetchingAddress = false;

    // --- Geolocation ---
    function initLocation() {
        if ("geolocation" in navigator) {
            navigator.geolocation.watchPosition(
                async (pos) => {
                    rawLat = pos.coords.latitude;
                    rawLon = pos.coords.longitude;
                    
                    gpsDot.classList.add('active');
                    gpsDot.classList.remove('warn');
                    
                    // Only fetch if we don't have an address and aren't currently loading one
                    if (!humanAddress && !isFetchingAddress) {
                        await fetchAddress(rawLat, rawLon);
                    }
                },
                (err) => {
                    gpsDot.classList.remove('active');
                    locText.textContent = "GPS Error";
                },
                { enableHighAccuracy: true }
            );
        } else {
            locText.textContent = "No GPS Support";
        }
    }

    async function fetchAddress(lat, lon) {
        isFetchingAddress = true;
        locText.textContent = "Locating...";
        
        try {
            // Setup 3 second timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);

            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`, {
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (!response.ok) throw new Error('API limit or error');
            
            const data = await response.json();
            
            if (data && data.address) {
                const parts = [];
                const a = data.address;
                if (a.suburb || a.neighbourhood) parts.push(a.suburb || a.neighbourhood);
                if (a.city || a.town || a.village) parts.push(a.city || a.town || a.village);
                if (a.country) parts.push(a.country);

                humanAddress = parts.slice(0, 3).join(', ');
                locText.textContent = humanAddress;
            } else {
                throw new Error('No address found');
            }
        } catch (e) {
            console.log("Fallback to Coordinates:", e);
            // FALLBACK: Use raw coordinates if API fails/timeouts
            humanAddress = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
            locText.textContent = "GPS Location (Offline)";
            gpsDot.classList.add('warn'); // Yellow dot for offline mode
        } finally {
            isFetchingAddress = false;
        }
    }

    // --- Camera ---
    async function startCamera() {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            currentStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: facingMode, width: { ideal: 1920 }, height: { ideal: 1080 } },
                audio: false
            });
            video.srcObject = currentStream;
        } catch (err) {
            alert("Camera Error: " + err.message);
        }
    }

    switchBtn.addEventListener('click', () => {
        facingMode = facingMode === 'environment' ? 'user' : 'environment';
        startCamera();
    });

    // --- Capture ---
    captureBtn.addEventListener('click', () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        if (facingMode === 'user') {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
        }
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        if (facingMode === 'user') ctx.setTransform(1, 0, 0, 1, 0, 0);

        drawOverlay();

        const dataURL = canvas.toDataURL('image/jpeg', 0.95);
        photoPreview.src = dataURL;
        video.classList.add('hidden');
        photoPreview.style.display = 'block';
        captureBtn.classList.add('hidden');
        switchBtn.classList.add('hidden');
        resultActions.style.display = 'flex';

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        downloadLink.href = dataURL;
        downloadLink.download = `GeoSnap-${timestamp}.jpg`;
    });

    function drawOverlay() {
        const h = canvas.height;
        const w = canvas.width;
        
        const gradient = ctx.createLinearGradient(0, h - 200, 0, h);
        gradient.addColorStop(0, "transparent");
        gradient.addColorStop(1, "rgba(0,0,0,0.9)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, h - 200, w, 200);

        ctx.fillStyle = "white";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 4;
        ctx.textAlign = "left";

        const fontSizeTime = Math.floor(w * 0.045); 
        ctx.font = `bold ${fontSizeTime}px sans-serif`;
        const timeStr = new Date().toLocaleString([], { dateStyle: 'medium', timeStyle: 'short' });
        ctx.fillText(timeStr, 20, h - 100);

        const fontSizeLoc = Math.floor(w * 0.025);
        ctx.font = `${fontSizeLoc}px sans-serif`;
        
        // Use human address if available, otherwise force raw coordinates
        const locString = humanAddress || `Lat: ${rawLat?.toFixed(5)} Lon: ${rawLon?.toFixed(5)}`;
        wrapText(ctx, locString, 20, h - 60, w - 40, fontSizeLoc * 1.5);
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = context.measureText(testLine);
            if (metrics.width > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            } else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }

    retryBtn.addEventListener('click', () => {
        photoPreview.style.display = 'none';
        video.classList.remove('hidden');
        resultActions.style.display = 'none';
        captureBtn.classList.remove('hidden');
        switchBtn.classList.remove('hidden');
    });

    initLocation();
    startCamera();

</script>
</body>
</html>
